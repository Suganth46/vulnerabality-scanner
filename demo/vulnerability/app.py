from flask import Flask, request, render_template, jsonify
import requests
import time
import os
import hashlib
import re
import mimetypes
from werkzeug.utils import secure_filename

app = Flask(__name__)

# File upload settings
UPLOAD_FOLDER = 'temp_uploads'
ALLOWED_EXTENSIONS = {'txt', 'php', 'py', 'js', 'html', 'css', 'xml', 'json', 'java', 'cpp', 'c', 'cs'}
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

# Ensure upload directory exists
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

# File scanning patterns
FILE_PATTERNS = {
    r'(?i)eval\s*\(': 'Dangerous eval() function',
    r'(?i)exec\s*\(': 'Dangerous exec() function',
    r'(?i)system\s*\(': 'System command execution',
    r'(?i)os\.system': 'OS command execution',
    r'(?i)subprocess\.': 'Subprocess execution',
    r'(?i)<script': 'JavaScript injection',
    r'(?i)document\.cookie': 'Cookie manipulation',
    r'(?i)innerHTML': 'Potential XSS',
    r'(?i)fromcharcode': 'Potential obfuscated code',
    r'(?i)base64_decode': 'Base64 decoded content',
    r'(?i)passthru\s*\(': 'Command execution function',
    r'(?i)shell_exec\s*\(': 'Shell command execution',
    r'(?i)file_get_contents\s*\(': 'File operation function',
    r'(?i)include\s*\(': 'File inclusion',
    r'(?i)require\s*\(': 'File requirement',
    r'(?i)fopen\s*\(': 'File operation',
    r'(?i)mysql_query': 'Direct MySQL query',
    r'(?i)exec\s*\(': 'Command execution'
}

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS
def perform_sql_injection_check(target_url):
    injection_payload = "'"
    try:
        response = requests.get(target_url + injection_payload)
        if "SQL syntax" in response.text or "sql" in response.text.lower():
            return "SQL injection vulnerability found!"
    except requests.RequestException as e:
        return f"Error during SQL Injection test: {e}"
    return "No SQL injection vulnerability detected."

def perform_xss_check(target_url):
    xss_payload = "<script>alert('XSS')</script>"
    try:
        response = requests.get(target_url, params={"input": xss_payload})
        if xss_payload in response.text:
            return "XSS vulnerability found!"
    except requests.RequestException as e:
        return f"Error during XSS test: {e}"
    return "No XSS vulnerability detected."


def perform_csrf_check(target_url):
    try:
        response = requests.get(target_url)
        if "csrf_token = " in response.text:
            csrf_token = response.text.split("csrf_token = ")[1].split(";")[0]
            payload = {"csrf_token": csrf_token}
            response = requests.post(target_url, data=payload)
            if "Invalid CSRF token" not in response.text:
                return "CSRF vulnerability found!"
        else:
            return "No CSRF token detected in the response."
    except requests.RequestException as e:
        return f"Error during CSRF test: {e}"
    return "No CSRF vulnerability detected."



def perform_ssrf_check(target_url):
    ssrf_payload = "http://localhost"
    try:
        response = requests.get(target_url, params={"input": ssrf_payload})
        if "Error connecting" not in response.text:
            return "SSRF vulnerability found!"
    except requests.RequestException as e:
        return f"Error during SSRF test: {e}"
    return "No SSRF vulnerability detected."

def perform_lfi_check(target_url):
    lfi_payload = "../../../etc/passwd"
    try:
        response = requests.get(target_url, params={"file": lfi_payload})
        if "root:" in response.text:
            return "LFI vulnerability found!"
    except requests.RequestException as e:
        return f"Error during LFI test: {e}"
    return "No LFI vulnerability detected."

def perform_rce_check(target_url):
    rce_payload = ";ls"
    try:
        response = requests.get(target_url, params={"input": rce_payload})
        if "bin" in response.text:
            return "RCE vulnerability found!"
    except requests.RequestException as e:
        return f"Error during RCE test: {e}"
    return "No RCE vulnerability detected."

def perform_command_injection_check(target_url):
    cmd_payload = ";echo Vulnerable"
    try:
        response = requests.get(target_url, params={"cmd": cmd_payload})
        if "Vulnerable" in response.text:
            return "Command Injection vulnerability found!"
    except requests.RequestException as e:
        return f"Error during Command Injection test: {e}"
    return "No Command Injection vulnerability detected."

def perform_open_redirect_check(target_url):
    redirect_payload = "/example.com"
    try:
        response = requests.get(target_url, params={"next": redirect_payload})
        if "example.com" in response.url:
            return "Open Redirect vulnerability found!"
    except requests.RequestException as e:
        return f"Error during Open Redirect test: {e}"
    return "No Open Redirect vulnerability detected."

def perform_file_upload_check(target_url):
    try:
        files = {'file': ('test.txt', 'This is a test file')}
        response = requests.post(target_url, files=files)
        if response.status_code == 200 and "test.txt" in response.text:
            return "File Upload vulnerability found!"
    except requests.RequestException as e:
        return f"Error during File Upload test: {e}"
    return "No File Upload vulnerability detected."

def perform_directory_traversal_check(target_url):
    traversal_payload = "../../../../etc/passwd"
    try:
        response = requests.get(target_url, params={"file": traversal_payload})
        if "root:" in response.text:
            return "Directory Traversal vulnerability found!"
    except requests.RequestException as e:
        return f"Error during Directory Traversal test: {e}"
    return "No Directory Traversal vulnerability detected."

def perform_xxe_check(target_url):
    xxe_payload ="""  <?xml version="1.0" encoding="ISO-8859-1"?>
    <!DOCTYPE foo [ <!ELEMENT foo ANY >
    <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
    <foo>&xxe;</foo> """
    headers = {"Content-Type": "application/xml"}
    try:
        response = requests.post(target_url, data=xxe_payload, headers=headers)
        if "root:" in response.text:
            return "XXE vulnerability found!"
    except requests.RequestException as e:
        return f"Error during XXE test: {e}"
    return "No XXE vulnerability detected."

def perform_crlf_injection_check(target_url):
    crlf_payload = "%0D%0AHeader-Test: Hello"
    try:
        response = requests.get(target_url + crlf_payload)
        if "Header-Test" in response.headers:
            return "CRLF Injection vulnerability found!"
    except requests.RequestException as e:
        return f"Error during CRLF Injection test: {e}"
    return "No CRLF Injection vulnerability detected."

def perform_http_response_splitting_check(target_url):
    splitting_payload = "%0d%0aContent-Length:0"
    try:
        response = requests.get(target_url + splitting_payload)
        if response.status_code == 200:
            return "HTTP Response Splitting vulnerability found!"
    except requests.RequestException as e:
        return f"Error during HTTP Response Splitting test: {e}"
    return "No HTTP Response Splitting vulnerability detected."

def perform_clickjacking_check(target_url):
    try:
        response = requests.get(target_url)
        if "X-Frame-Options" not in response.headers:
            return "Clickjacking vulnerability found!"
    except requests.RequestException as e:
        return f"Error during Clickjacking test: {e}"
    return "No Clickjacking vulnerability detected."

def scan_file(file_path):
    vulnerabilities = []
    
    try:
        # Get file type
        file_type = mimetypes.guess_type(file_path)[0] or 'application/octet-stream'
        
        # Calculate file hash
        sha256_hash = hashlib.sha256()
        with open(file_path, "rb") as f:
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        
        # Read and scan file content
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()
            
            # Check for dangerous patterns
            for pattern, description in FILE_PATTERNS.items():
                matches = re.finditer(pattern, content)
                for match in matches:
                    line_number = content[:match.start()].count('\n') + 1
                    context_start = max(0, match.start() - 50)
                    context_end = min(len(content), match.end() + 50)
                    context = content[context_start:context_end]
                    
                    vulnerabilities.append({
                        'type': description,
                        'line': line_number,
                        'pattern': match.group(),
                        'context': context.strip()
                    })
        
        # Additional security checks
        security_checks = []
        
        # Check file size
        file_size = os.path.getsize(file_path)
        if file_size > 10 * 1024 * 1024:  # 10MB
            security_checks.append("Large file size detected (>10MB)")
            
        # Check file permissions
        try:
            file_perms = oct(os.stat(file_path).st_mode)[-3:]
            if file_perms == '777':
                security_checks.append("Unsafe file permissions (777)")
        except:
            pass
            
        return {
            'filename': os.path.basename(file_path),
            'file_type': file_type,
            'file_size': file_size,
            'sha256': sha256_hash.hexdigest(),
            'vulnerabilities': vulnerabilities,
            'security_checks': security_checks
        }
        
    except Exception as e:
        return {'error': str(e)}

# Web vulnerability scanning functions (existing functions remain the same)
def perform_sql_injection_check(target_url):
    injection_payload = "'"
    try:
        response = requests.get(target_url + injection_payload)
        if "SQL syntax" in response.text or "sql" in response.text.lower():
            return "SQL injection vulnerability found!"
    except requests.RequestException as e:
        return f"Error during SQL Injection test: {e}"
    return "No SQL injection vulnerability detected."

# [Keep all other existing pentest functions...]

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/scan_file', methods=['POST'])
def scan_file_endpoint():
    if 'file' not in request.files:
        return jsonify({'error': 'No file uploaded'})
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No file selected'})
        
    if not allowed_file(file.filename):
        return jsonify({'error': 'File type not allowed'})
    
    filename = secure_filename(file.filename)
    filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    
    try:
        file.save(filepath)
        result = scan_file(filepath)
        os.remove(filepath)  # Clean up
        return jsonify(result)
    except Exception as e:
        if os.path.exists(filepath):
            os.remove(filepath)
        return jsonify({'error': str(e)})

@app.route('/scan_url', methods=['POST'])
def scan_url():
    target_url = request.form['url']
    start_time = time.time()
    
    results = {
        "SQL Injection": perform_sql_injection_check(target_url),
        "XSS": perform_xss_check(target_url),
        "CSRF": perform_csrf_check(target_url),
        "SSRF": perform_ssrf_check(target_url),
        "LFI": perform_lfi_check(target_url),
        "RCE": perform_rce_check(target_url),
        "Command Injection": perform_command_injection_check(target_url),
        "Open Redirect": perform_open_redirect_check(target_url),
        "File Upload": perform_file_upload_check(target_url),
        "Directory Traversal": perform_directory_traversal_check(target_url),
        "XXE": perform_xxe_check(target_url),
        "CRLF Injection": perform_crlf_injection_check(target_url),
        "HTTP Response Splitting": perform_http_response_splitting_check(target_url),
        "Clickjacking": perform_clickjacking_check(target_url)
    }
    
    end_time = time.time()
    elapsed_time = round(end_time - start_time, 2)
    detected_count = sum("found" in result.lower() for result in results.values())
    
    return jsonify({
        "results": results,
        "elapsed_time": elapsed_time,
        "detected_count": detected_count
    })

if __name__ == "__main__":
    app.run(debug=True)