import re
import requests
import socket
import ssl
import urllib.parse
import jwt
import concurrent.futures
from typing import Dict, List, Any

class VulnerabilityScanner:
    def __init__(self, targetUrl: str):
        self.targetUrl = targetUrl
        self.parsed_url = urllib.parse.urlparse(targetUrl)
        self.headers = {
            'User-Agent': 'VSCAN Pro Security Scanner',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
        }

    def scan_sql_injection(self) -> Dict[str, Any]:
        test_payloads = [
            "' OR '1'='1",
            "1' OR '1' = '1",
            "1' OR 1=1--+"
        ]
        
        try:
            for payload in test_payloads:
                test_url = f"{self.targetUrl}{payload}"
                response = requests.get(test_url, headers=self.headers, timeout=5)
                
                # Check for potential SQL injection indicators
                if any(keyword in response.text.lower() for keyword in ['error', 'mysql', 'syntax']):
                    return {
                        'warning': True,
                        'warningDetails': f'Potential SQL Injection vulnerability detected with payload: {payload}'
                    }
            
            return {'safe': True}
        except Exception as e:
            return {
                'critical': True,
                'criticalDetails': f'Error during SQL Injection scan: {str(e)}'
            }

    def scan_xss(self) -> Dict[str, Any]:
        test_payloads = [
            '<script>alert("XSS")</script>',
            'javascript:alert("XSS")',
            '\'"(){}[]><script>alert(1)</script>'
        ]
        
        try:
            for payload in test_payloads:
                test_url = f"{self.targetUrl}?test={urllib.parse.quote(payload)}"
                response = requests.get(test_url, headers=self.headers, timeout=5)
                
                if payload in response.text:
                    return {
                        'warning': True,
                        'warningDetails': f'Potential XSS vulnerability with payload: {payload}'
                    }
            
            return {'safe': True}
        except Exception as e:
            return {
                'critical': True,
                'criticalDetails': f'Error during XSS scan: {str(e)}'
            }

    def scan_ssl_security(self) -> Dict[str, Any]:
        try:
            hostname = self.parsed_url.netloc
            context = ssl.create_default_context()
            with socket.create_connection((hostname, 443)) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as secure_sock:
                    cert = secure_sock.getpeercert()
                    
                    # Check certificate expiration
                    import datetime
                    expiry = datetime.datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                    if expiry < datetime.datetime.now():
                        return {
                            'warning': True,
                            'warningDetails': 'SSL Certificate has expired'
                        }
                    
                    return {'safe': True}
        except Exception as e:
            return {
                'critical': True,
                'criticalDetails': f'SSL/TLS Security Check Failed: {str(e)}'
            }

    def scan_security_headers(self) -> Dict[str, Any]:
        required_headers = [
            'Strict-Transport-Security',
            'X-Frame-Options',
            'X-XSS-Protection',
            'Content-Security-Policy'
        ]
        
        try:
            response = requests.head(self.targetUrl, headers=self.headers, timeout=5)
            missing_headers = [
                header for header in required_headers 
                if header.lower() not in [h.lower() for h in response.headers]
            ]
            
            if missing_headers:
                return {
                    'warning': True,
                    'warningDetails': f'Missing security headers: {", ".join(missing_headers)}'
                }
            
            return {'safe': True}
        except Exception as e:
            return {
                'critical': True,
                'criticalDetails': f'Security Headers Scan Failed: {str(e)}'
            }

    def perform_comprehensive_scan(self, checks: List[str]) -> Dict[str, Dict[str, Any]]:
        scan_methods = {
            'sqlInjection': self.scan_sql_injection,
            'xss': self.scan_xss,
            'SSL/TLS Security': self.scan_ssl_security,
            'Security Headers': self.scan_security_headers
        }
        
        results = {}
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
            futures = {
                check: executor.submit(scan_methods[check]) 
                for check in checks if check in scan_methods
            }
            
            for check, future in futures.items():
                results[check] = future.result()
        
        return results

def validate_url(targetUrl: str) -> bool:
    url_regex = re.compile(
        r'^https?://'  # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+[A-Z]{2,6}\.?|'  # domain...
        r'localhost|'  # localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})'  # ...or ip
        r'(?::\d+)?'  # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)
    
    return bool(url_regex.match(targetUrl))