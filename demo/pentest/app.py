import os
from flask import Flask, render_template, request, jsonify
import requests
from bs4 import BeautifulSoup
import urllib.parse
import logging
import re
from datetime import datetime
from typing import Dict, List, Optional

app = Flask(__name__)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class SecurityScanner:
    def __init__(self, target_url: str):
        self.target_url = target_url.rstrip('/')
        self.session = requests.Session()
        
    def _safe_request(self, url: str, method: str = 'GET', 
                     data: Optional[Dict] = None, 
                     headers: Optional[Dict] = None,
                     timeout: int = 10) -> Optional[requests.Response]:
        try:
            response = self.session.request(
                method, 
                url, 
                data=data, 
                headers=headers, 
                timeout=timeout,
                verify=False  # For testing only - enable SSL verification in production
            )
            return response
        except requests.exceptions.RequestException as e:
            logger.error(f"Request failed: {str(e)}")
            return None

    def check_sql_injection(self) -> Dict:
        """Test for SQL injection vulnerabilities"""
        test_payloads = [
            "1' OR '1'='1",
            "admin' --",
            "1; DROP TABLE users",
            "1' UNION SELECT NULL--",
        ]
        findings = []
        
        for payload in test_payloads:
            test_url = f"{self.target_url}?id={urllib.parse.quote(payload)}"
            response = self._safe_request(test_url)
            
            if response:
                # Check for SQL errors in response
                sql_errors = [
                    'sql syntax',
                    'mysql error',
                    'sqlite error',
                    'postgresql error',
                    'ORA-',
                    'SQL Server error'
                ]
                
                if any(error in response.text.lower() for error in sql_errors):
                    findings.append({
                        'payload': payload,
                        'url': test_url,
                        'status': 'danger',
                        'detail': 'Potential SQL injection vulnerability detected'
                    })
        
        status = 'danger' if findings else 'safe'
        return {
            'name': 'SQL Injection',
            'status': status,
            'findings': findings
        }

    def check_xss(self) -> Dict:
        """Test for XSS vulnerabilities"""
        test_payloads = [
            '<script>alert(1)</script>',
            '"><script>alert(1)</script>',
            '<img src=x onerror=alert(1)>',
            '<svg onload=alert(1)>',
        ]
        findings = []
        
        for payload in test_payloads:
            test_url = f"{self.target_url}?q={urllib.parse.quote(payload)}"
            response = self._safe_request(test_url)
            
            if response and payload in response.text:
                findings.append({
                    'payload': payload,
                    'url': test_url,
                    'status': 'danger',
                    'detail': 'Potential XSS vulnerability detected'
                })
        
        status = 'danger' if findings else 'safe'
        return {
            'name': 'Cross-Site Scripting (XSS)',
            'status': status,
            'findings': findings
        }

    def check_csrf(self) -> Dict:
        """Check for CSRF protections"""
        findings = []
        response = self._safe_request(self.target_url)
        
        if response:
            # Check for CSRF tokens in forms
            soup = BeautifulSoup(response.text, 'html.parser')
            forms = soup.find_all('form')
            
            for form in forms:
                csrf_token = form.find('input', attrs={'name': re.compile(r'csrf|token', re.I)})
                if not csrf_token:
                    findings.append({
                        'form_action': form.get('action', ''),
                        'status': 'warning',
                        'detail': 'Form without CSRF token detected'
                    })
            
            # Check for SameSite cookie attribute
            if 'Set-Cookie' in response.headers:
                if 'SameSite' not in response.headers['Set-Cookie']:
                    findings.append({
                        'cookie': response.headers['Set-Cookie'],
                        'status': 'warning',
                        'detail': 'Cookie without SameSite attribute detected'
                    })
        
        status = 'danger' if findings else 'safe'
        return {
            'name': 'CSRF Protection',
            'status': status,
            'findings': findings
        }

    def check_directory_traversal(self) -> Dict:
        """Test for directory traversal vulnerabilities"""
        test_paths = [
            '../../../etc/passwd',
            '..%2f..%2f..%2fetc%2fpasswd',
            '....//....//....//etc/passwd',
            '..\\..\\..',
        ]
        findings = []
        
        for path in test_paths:
            test_url = f"{self.target_url}?file={urllib.parse.quote(path)}"
            response = self._safe_request(test_url)
            
            if response and any(x in response.text for x in ['root:', 'bin:', '/usr/bin']):
                findings.append({
                    'path': path,
                    'url': test_url,
                    'status': 'danger',
                    'detail': 'Potential directory traversal vulnerability detected'
                })
        
        status = 'danger' if findings else 'safe'
        return {
            'name': 'Directory Traversal',
            'status': status,
            'findings': findings
        }

    def check_file_upload(self) -> Dict:
        """Test file upload security"""
        test_files = {
            'malicious.php': ('malicious.php', '<?php echo "test"; ?>', 'application/x-php'),
            'malicious.php.jpg': ('malicious.php.jpg', '<?php echo "test"; ?>', 'image/jpeg'),
            'large_file.txt': ('large_file.txt', 'A' * 1024 * 1024, 'text/plain'),
        }
        findings = []
        
        for filename, file_data in test_files.items():
            files = {'file': file_data}
            response = self._safe_request(
                f"{self.target_url}/upload",
                method='POST',
                data={},
                files=files
            )
            
            if response and response.status_code == 200:
                findings.append({
                    'filename': filename,
                    'status': 'warning',
                    'detail': f'Potentially unsafe file upload accepted: {filename}'
                })
        
        status = 'warning' if findings else 'safe'
        return {
            'name': 'File Upload',
            'status': status,
            'findings': findings
        }

    def run_all_checks(self) -> Dict:
        """Run all security checks"""
        results = {
            'scan_time': datetime.now().isoformat(),
            'target_url': self.target_url,
            'checks': {}
        }
        
        checks = [
            self.check_sql_injection,
            self.check_xss,
            self.check_csrf,
            self.check_directory_traversal,
            self.check_file_upload
        ]
        
        for check in checks:
            try:
                check_result = check()
                results['checks'][check.__name__] = check_result
            except Exception as e:
                logger.error(f"Error in {check.__name__}: {str(e)}")
                results['checks'][check.__name__] = {
                    'name': check.__name__,
                    'status': 'error',
                    'error': str(e)
                }
        
        return results

# Routes
@app.route('/')
def index():
    return render_template('index.html')

@app.route('/scan', methods=['POST'])
def scan():
    target_url = request.json.get('url')
    selected_checks = request.json.get('checks', [])
    
    if not target_url:
        return jsonify({'error': 'No target URL provided'}), 400
    
    scanner = SecurityScanner(target_url)
    results = scanner.run_all_checks()
    
    # Filter results based on selected checks
    if selected_checks:
        results['checks'] = {k: v for k, v in results['checks'].items() 
                           if k in selected_checks}
    
    return jsonify(results)

@app.route('/report/<scan_id>')
def report(scan_id):
    # Implement report generation logic here
    pass

if __name__ == '__main__':
    app.run(debug=True)